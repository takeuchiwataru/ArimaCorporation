//=============================================================================
//
// ひよこの処理 [chick.cpp]
// Author : 長山拓実
//
//=============================================================================
#include "scene.h"
#include "chick.h"
#include "manager.h"
#include "object.h"
#include "meshfield.h"
#include "player.h"
#include "fade.h"
#include "shadow.h"
#include "tutorial.h"
#include "ColMesh.h"
#include "egg.h"

//*****************************************************************************
// マクロ定義
//*****************************************************************************

#define MODEL_SPEED				(5.0f)
#define OBJCT_ANGLE_REVISION	(0.2f)		// 角度補正
#define EFFECT_HIGHT			(250.0f)	// エミッターの高さ
#define FOUNTAIN_UP				(20.0f)		// 噴水の上昇させる値
#define DISTIME					(100)		// 消えるまでの時間
#define CHICK_SPEED				(30.0f)		// ひよこが飛んでくスピード
#define ANNOY_RANGE				(200.0f)	// 減速させる範囲
#define ATTACK_RANGE			(200.0f)	// 範囲攻撃の範囲
#define CHICK_JUMP				(3.5f)		// ジャンプ力
#define CHICK_FALL_TIME			(30)		// ひよこが落ちてくるタイミングの間隔
#define CHICK_FALL_SPEED		(10.0f)		// 落ちてくるひよこの速さ

//更新範囲
#define FOUNTAIN_LENGTH			(15000)		//噴水の更新範囲
#define LEAF_LENGTH				(10500)		//葉の更新処理
#define WOOD_LENGTH				(8000)		//木をビルボードに入れ替える距離
#define FLOWER_LENGTH			(5500)		//花壇の描画範囲

//*****************************************************************************
// プロトタイプ宣言
//*****************************************************************************

//*****************************************************************************
// グローバル変数:
//*****************************************************************************

//*****************************************************************************
// 静的メンバ変数
//*****************************************************************************
D3DXVECTOR3 CChick::m_VtxMaxModel = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
D3DXVECTOR3 CChick::m_VtxMinModel = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

//===============================================================================
//　デフォルトコンストラクタ
//===============================================================================
CChick::CChick() : CModel3D(EGG_PRIOTITY, CScene::OBJTYPE_CHICK)
{
	m_scale = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 大きさ
	m_pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_posOld = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_move = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_fDestAngle = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_fDiffAngle = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_FNor = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_fHeight = 0.0f;
	m_fLength = 0.0f;
	m_nRank = 0;
	m_nNumPlayer = 0;
	m_nDisTimer = 0;
	m_DestRank = 0;
	m_nMap = 0;
}
//===============================================================================
//　デストラクタ
//===============================================================================
CChick::~CChick() {}

//===============================================================================
//　生成
//===============================================================================
CChick * CChick::Create(D3DXVECTOR3 pos, D3DXVECTOR3 rot, D3DXVECTOR3 scale, TYPE type, BULLETTYPE bulletType, STATE state, int nNumPlayer)
{
	CChick *pChick = NULL;

	// NULLチェック
	if (pChick == NULL)
	{// メモリの動的確保

		pChick = new CChick;

		if (pChick != NULL)
		{
			pChick->SetModelType(MODEL_TYPE_CHICK);
			// テクスチャの設定
			pChick->SetTextureType(type + TEXTURE_TYPE_CHICK_K);
			// サイズを代入
			pChick->m_scale = scale;
			// サイズを親クラスに代入
			pChick->SetScale(scale);
			// 卵の種類を代入
			pChick->m_type = type;
			// 弾の種類を代入
			pChick->m_bulletType = bulletType;
			// オブジェクトクラスの生成
			pChick->Init();
			// 位置を代入
			pChick->SetPosition(pos);
			pChick->m_pos = pos;
			pChick->m_fHeight = pos.y;
			// 回転を反映
			pChick->SetRot(rot);
			// 何位の卵か
			pChick->m_nNumPlayer = nNumPlayer;
			// 状態の設定
			pChick->m_state = state;
		}
	}

	return pChick;
}

//=============================================================================
// 初期化処理
//=============================================================================
HRESULT CChick::Init(void)
{
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();

	//3DモデルのInit
	CModel3D::Init();

	// 各種情報の代入
	CModel3D::SetScale(m_scale);

	//変数の初期化
	m_pObjBill = NULL;
	m_move = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_fHeight = 0.0f;
	m_fDestAngle = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_fDiffAngle = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_posOld = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_FNor = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	m_fLength = 3.0f;
	m_bJump = false;
	m_bDis = true;
	m_state = STATE_NORMAL;
	m_nRank = 0;
	m_nNumPlayer = 0;
	m_nDisTimer = 0;
	m_DestRank = -1;
	m_nMap = 0;
	m_bAttackS = false;
	m_bExplosion = false;

	return S_OK;
}

//=============================================================================
// 終了処理
//=============================================================================
void CChick::Uninit(void)
{
	//オブジェクトビルボード
	m_pObjBill = NULL;

	//3DモデルのUninit
	CModel3D::Uninit();
}

//=============================================================================
// 更新処理
//=============================================================================
void CChick::Update(void)
{
	//m_pos = CModel3D::GetPosition();
	m_posOld = m_pos;	//前回の位置を保存する

	// ひよこの動き
	Move();

	CModel3D::SetPosition(D3DXVECTOR3(m_pos.x, m_pos.y + 5.0f, m_pos.z));
	CModel3D::SetRot(m_rot);
}
//=============================================================================
// 描画処理
//=============================================================================
void CChick::Draw(void)
{
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();

	//頂点法線の自動正規化
	pDevice->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);

	if (m_bExplosion == false)
	{
		//描画処理
		//CModel3D::Draw();
	}

	//頂点法線の自動正規化
	pDevice->SetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
}

//===============================================================================
// Xファイルの読み込み
//===============================================================================
HRESULT CChick::Load(void)
{
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();

	//マテリアルデータへのポインタ
	//D3DXMATERIAL *pMat;

	////マテリアル情報からテクスチャの取得
	//pMat = (D3DXMATERIAL*)m_pBuffMatModel->GetBufferPointer();

	//int nNumVtx;		//頂点数
	//DWORD sizeFVF;		//頂点フォーマットのサイズ
	//BYTE *pVtxBuff;		//頂点バッファへのポインタ

	////モデルの最大値・最小値を取得する
	//m_VtxMaxModel = D3DXVECTOR3(-10000, -10000, -10000);	//最大値
	//m_VtxMinModel = D3DXVECTOR3(10000, 10000, 10000);	//最小値

	////頂点数を取得
	//nNumVtx = m_pMeshModel->GetNumVertices();

	////頂点フォーマットのサイズを取得
	//sizeFVF = D3DXGetFVFVertexSize(m_pMeshModel->GetFVF());

	////頂点バッファのロック
	//m_pMeshModel->LockVertexBuffer(D3DLOCK_READONLY, (void**)&pVtxBuff);

	//for (int nCntVtx = 0; nCntVtx < nNumVtx; nCntVtx++)
	//{
	//	D3DXVECTOR3 vtx = *(D3DXVECTOR3*)pVtxBuff;		//頂点座標の代入

	//	//最大値
	//	if (vtx.x > m_VtxMaxModel.x)
	//	{
	//		m_VtxMaxModel.x = vtx.x;
	//	}
	//	if (vtx.y > m_VtxMaxModel.y)
	//	{
	//		m_VtxMaxModel.y = vtx.y;
	//	}
	//	if (vtx.z > m_VtxMaxModel.z)
	//	{
	//		m_VtxMaxModel.z = vtx.z;
	//	}
	//	//最小値
	//	if (vtx.x < m_VtxMinModel.x)
	//	{
	//		m_VtxMinModel.x = vtx.x;
	//	}
	//	if (vtx.y < m_VtxMinModel.y)
	//	{
	//		m_VtxMinModel.y = vtx.y;
	//	}
	//	if (vtx.z < m_VtxMinModel.z)
	//	{
	//		m_VtxMinModel.z = vtx.z;
	//	}

	//	//サイズ文のポインタを進める
	//	pVtxBuff += sizeFVF;
	//}

	////頂点バッファのアンロック
	//m_pMeshModel->UnlockVertexBuffer();

	return S_OK;
}

//===============================================================================
// テクスチャの破棄
//===============================================================================
void CChick::UnLoad(void)
{

}

//===============================================================================
// ひよこの動き
//===============================================================================
void CChick::Move(void)
{
	// 使ったとき
	Item();

	if ((m_type != TYPE_ANNOY && m_type != TYPE_ATTACK_S && m_type != TYPE_ANNOY_S) || m_state != STATE_BULLET)
	{
		m_move.y -= cosf(0) * 0.1f;
	}

	m_pos.x += m_move.x;
	m_pos.y += m_move.y;
	m_pos.z += m_move.z;

	if (m_bDis == false)
	{
		m_nDisTimer++;

		if (m_nDisTimer > DISTIME)
		{// 消す
			m_nDisTimer = 0;
			Uninit();
		}
	}

	if ((m_type != TYPE_ATTACK_S || m_type != TYPE_ANNOY_S) && m_state == STATE_CHASE)
	{
		//マップとの当たり判定
		CPlayer **pPlayer = NULL;
		pPlayer = CGame::GetPlayer();

		m_fHeight = CCOL_MESH_MANAGER::GetHeight(m_pos, pPlayer[m_nNumPlayer]->GetnMap());

		if (m_pos.y < m_fHeight)
		{
			m_move.y = 0.0f;
			m_pos.y = m_fHeight/* + 10.0f*/;
			//ジャンプの状態設定
			m_bJump = false;
		}
	}
	else if (m_type == TYPE_ATTACK && m_state == STATE_BULLET)
	{
		//マップとの当たり判定
		CPlayer **pPlayer = NULL;
		pPlayer = CGame::GetPlayer();

		m_fHeight = CCOL_MESH_MANAGER::GetHeight(m_pos, pPlayer[m_nNumPlayer]->GetnMap());

		if (m_pos.y < m_fHeight)
		{
			m_move.y = 0.0f;
			m_pos.y = m_fHeight/* + 10.0f*/;
			//ジャンプの状態設定
			m_bJump = false;
		}
	}

	//CDebugProc::Print("%.1f\n", m_move.y);
}

//===============================================================================
// ひよこを使用したときの動き
//===============================================================================
void CChick::Item(void)
{
	if (m_state == STATE_BULLET)
	{// 弾の状態の時
		float fHeight = 0.0f;
		CPlayer **pPlayer = NULL;

		switch (m_type)
		{
			// 攻撃
		case TYPE_ATTACK:
			break;

			// 減速させる
		case TYPE_ANNOY:
			pPlayer = CGame::GetPlayer();

			m_pos = D3DXVECTOR3(pPlayer[m_nNumPlayer]->GetPos().x, pPlayer[m_nNumPlayer]->GetPos().y + 60.0f, pPlayer[m_nNumPlayer]->GetPos().z);

			break;
		}
		// 飛んでく動き
		Bullet();
	}
}

//===============================================================================
// 当たり判定
//===============================================================================
bool CChick::CollisionChick(D3DXVECTOR3 * pPos, D3DXVECTOR3 * pPosOld)
{
	//あたっているかあたってないか
	bool bHit = false;

	if (m_state == STATE_BULLET)
	{
		// 各種情報の取得
		D3DXVECTOR3 ModelPos = CModel3D::GetPosition();		// 位置
		D3DXVECTOR3 VtxMax = CModel3D::GetVtxMax();			// モデルの最大値
		D3DXVECTOR3 VtxMin = CModel3D::GetVtxMin();			// モデルの最小値
		D3DXVECTOR3 rot = CModel3D::GetRot();

		D3DXVECTOR3 ModelMax = CModel3D::GetPosition() + CModel3D::GetVtxMax();	// 位置込みの最大値
		D3DXVECTOR3 ModelMin = CModel3D::GetPosition() + CModel3D::GetVtxMin();	// 位置込みの最小値

		float fDepth = PLAYER_DEPTH - 10.0f;

		if (m_type == TYPE_ANNOY)
		{
			fDepth = ANNOY_RANGE;
		}
		if (m_bExplosion == true)
		{
			fDepth = ATTACK_RANGE;
		}

		if (pPos->x >= ModelMin.x - fDepth && pPos->x <= ModelMax.x + fDepth)
		{// Zの範囲内にいる
			if (pPos->z >= ModelMin.z - fDepth && pPos->z <= ModelMax.z + fDepth)
			{// Xの範囲内にいる
				if (pPosOld->y >= ModelMax.y && pPos->y <= ModelMax.y)
				{// オブジェクトの上から当たる場合
					bHit = true;
				}
				else if (pPosOld->y + PLAYER_HEIGHT <= ModelMin.y && pPos->y + PLAYER_HEIGHT >= ModelMin.y)
				{// オブジェクトの下から当たる場合
					bHit = true;
				}

				if (!(pPos->y >= ModelMax.y) && !(pPos->y + PLAYER_HEIGHT <= ModelMin.y))
				{// オブジェクト横との当たり判定
					bHit = true;
				}
			}
		}

		if (bHit == true && m_type == TYPE_ATTACK)
		{
			m_bExplosion = true;
			m_bDis = false;
		}

		// 位置の代入
		CModel3D::SetPosition(ModelPos);
	}
	return bHit;
}

//=============================================================================
// 高さ判定
//=============================================================================
float CChick::SetHeight(void)
{
	float fHeight = 0.0f;

	CScene *pScene = CScene::GetTop(MESH_PRIOTITY);

	//NULLチェック
	while (pScene != NULL)
	{
		//UpdateでUninitされてしまう場合　Nextが消える可能性があるからNextにデータを残しておく
		CScene *pSceneNext = pScene->GetNext();

		if (pScene->GetObjType() == CScene::OBJTYPE_GROUND)
		{//タイプが地面だったら
			CMeshField *pField = (CMeshField*)pScene;

			if (pField->OnField(m_pos, 0.0f))
			{// 傾斜の計算
				fHeight = pField->GetHeightMesh(CModel3D::GetPosition());

				if (m_bJump == false || (m_bJump == true && m_fHeight < fHeight))
				{
					m_fHeight = fHeight + 15.0f;				//地面の高さを取得
					m_move.y = 0.0f;					//移動量を初期化する

														//ジャンプの状態設定
					m_bJump = false;

					CModel3D::SetMove(m_move);
					CModel3D::SetPosition(D3DXVECTOR3(m_pos.x, m_fHeight, m_pos.z));

					break;
				}
			}
		}
		//Nextに次のSceneを入れる
		pScene = pSceneNext;
	}

	return m_fHeight;
}

//=============================================================================
// ジャンプ
//=============================================================================
void CChick::Jump(float fJump)
{
	// ジャンプ
	if (m_bJump == false)
	{// ジャンプしていない
		m_bJump = true;
		m_move.y += fJump;
	}
}

//=============================================================================
// 飛んでく
//=============================================================================
void CChick::Bullet(void)
{
	if (m_bulletType == BULLETTYPE_PLAYER)
	{
		switch (m_type)
		{
			// 攻撃ひよこ
		case TYPE_ATTACK:
			// 1つ前のプレイヤーに飛んでいく
			Attack();
			break;

			// 強い攻撃ひよこ
		case TYPE_ATTACK_S:
			// 1位に全体攻撃
			AttackS();
			break;

			// 強い減速ひよこ
		case TYPE_ANNOY_S:
			// 1位に全体攻撃
			AnnoyS();
			break;
		}
	}

}

//=============================================================================
// 角度の調節
//=============================================================================
void CChick::AdjustAngle(float rot)
{
	if (rot > D3DX_PI)
	{
		rot -= D3DX_PI * 2.0f;
	}
	if (rot < -D3DX_PI)
	{
		rot += D3DX_PI * 2.0f;
	}
}

//=============================================================================
// 攻撃ひよこ
//=============================================================================
void CChick::Attack(void)
{
	CPlayer **pPlayer = CGame::GetPlayer();

	if (m_DestRank >= 0)
	{
		// 目的の角度
		m_fDestAngle.y = atan2f(pPlayer[m_DestRank]->GetPos().x - m_pos.x, pPlayer[m_DestRank]->GetPos().z - m_pos.z);

		// 差分
		m_fDiffAngle.y = m_fDestAngle.y - m_rot.y;

		AdjustAngle(m_fDiffAngle.y);

		m_rot.y += m_fDiffAngle.y * 0.5f;

		AdjustAngle(m_rot.y);

		//モデルの移動	モデルの移動する角度(カメラの向き + 角度) * 移動量
		m_move.x = sinf(m_rot.y) * CHICK_SPEED;
		m_move.z = cosf(m_rot.y) * CHICK_SPEED;
	}
	else
	{
		//モデルの移動	モデルの移動する角度(カメラの向き + 角度) * 移動量
		m_move.x = sinf(m_rot.y) * -CHICK_SPEED * 0.6f;
		m_move.z = cosf(m_rot.y) * -CHICK_SPEED * 0.6f;
	}

	CModel3D::SetRot(m_rot);
}

//=============================================================================
// 攻撃ひよこ(強い)
//=============================================================================
void CChick::AttackS(void)
{
	CPlayer **pPlayer = CGame::GetPlayer();

	if (m_nRank != 0)
	{
		if (m_bAttackS == false)
		{// 上がっていく
			m_move.x = pPlayer[m_nNumPlayer]->GetMove().x;
			m_move.y = 4.0f;
			m_move.z = pPlayer[m_nNumPlayer]->GetMove().z;

			if (m_pos.y > pPlayer[m_nNumPlayer]->GetPos().y + 300.0f)
			{// 隕石になるタイミング
				int fx = rand() % FALL_CHICK_RANGE;
				int fz = rand() % FALL_CHICK_RANGE;

				m_pos = D3DXVECTOR3(pPlayer[m_DestRank]->GetPos().x + ((FALL_CHICK_RANGE / 2) - fx),
					pPlayer[m_DestRank]->GetPos().y + 100.0f,
					pPlayer[m_DestRank]->GetPos().z + ((FALL_CHICK_RANGE / 2) - fz));

				if (pPlayer[m_nNumPlayer]->GetCntChick() < CHICK_FALL_NUM)
				{// 5匹まで出す
				 // 落ちるひよこ出現
					pPlayer[m_nNumPlayer]->FallChicks(D3DXVECTOR3(
						(sinf(pPlayer[m_DestRank]->GetRot().y + D3DX_PI)) + pPlayer[m_DestRank]->GetPos().x,
						pPlayer[m_DestRank]->GetPos().y,
						(cosf(pPlayer[m_DestRank]->GetRot().y + D3DX_PI)) + pPlayer[m_DestRank]->GetPos().z));
				}

				m_bAttackS = true;
				pPlayer[m_nNumPlayer]->SetCntChick(0);
			}
		}
		else
		{
			// 移動量を設定
			m_move.y = -CHICK_FALL_SPEED;
		}
	}

	CModel3D::SetRot(m_rot);
}

//=============================================================================
// 減速ひよこ(強い)
//=============================================================================
void CChick::AnnoyS(void)
{
	CPlayer **pPlayer = CGame::GetPlayer();

	if (m_bAttackS == false)
	{
		pPlayer[m_nNumPlayer]->AnnoyChicks();
		m_bAttackS = true;
	}
}